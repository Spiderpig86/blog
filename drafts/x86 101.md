# x86 101

## Why?

You might be wondering why I would subject myself to torture by trying to learn Assembly in the first place since it's "either too hard" or  "it's boring as hell". Well you're right, it's definitely not the most interesting thing in the world. Since I'm taking a course of offensive security, I *kinda* need to at least understand the basics of it -- mainly to understand program disassembling for CTF.

So far, there aren't too many simple guides on learning x86 online compared to other languages. So hopefully, this will be a quick and easy guide for you to follow  to learn the very basics of x86. :smile:

## What is x86?

*Worse than MIPS*. Just kidding. x86 is a variant of **Assembly** that is commonly written for x86-64 processors which are CISC processors (common in most desktop computers today). x86 is more complex than, let's say, MIPS in the sense that it is designed to complete tasks with only a few instructions rather than using more basic instructions.

For example, CISC architectures come with a built-in instruction that performs multiplication without breaking it up into a series of smaller instructions. In the RISC approach, multiplication is actually broken up into a series of a few instructions [2]. 

```asm
; CISC approach
; Imagine if dval1 = 0x5 and dval2 = 0x6
mov eax, dval1 ; Move the first value to accumulator
mul dval2 ; Multiply into eax
```

In the RISC approach, it is broken up into a series of other steps.

```asm
LOAD A, 2
LOAD B, 3
PROD A, B
STORE A, RES
```

## Program Components

Before we get started with the x86 language, first we must understand the main sections of a program written in C. This will be a very brief guide since there is plenty of info online. Note that what I will be talking about is the 32-bit variant of the x86 architecture.

#### Heap

The **heap** is a section of **unmanaged** memory (in Java, there's GC so technically it is managed there) that is allocated by the operating system. The OS uses the `sysbrk` syscall to allocate memory from the requesting function. Unlike the stack, memory is not invalidated when the function returns which leads to memory leaks. To avoid this, in C you would release memory with `free()` after a call to `malloc()` or one of its variants. Heap grows **upward** towards higher memory addresses.

#### Stack

This refers to the region of memory that is allocated to the process **primarily to implement functions**. This is managed in the sense that the variables created remain local to the function it resides and is invalidated once the function exits (when the [stack pointer](https://en.wikipedia.org/wiki/Stack_register) moves up). The values are still there, but they will be overwritten by the contents of the next function call's [stack frame](https://stackoverflow.com/questions/10057443/explain-the-concept-of-a-stack-frame-in-a-nutshell). Two x86 registers that deal with this are:

 * `esp` (extended stack pointer) - points to the top of the stack where `push` and `pop` will decrement and increment the stack pointer respectively. `push` adds an element to the top of the stack while `pop` removes the element at the top of the stack.
 * `ebp` (extended base pointer) - points to the start of the current **stack frame**, which is the space allocated for a function call. The `call` instruction pushes the current instruction pointer onto the stack.

Note that the stack grows **downward** towards lower memory addresses. This is also where global and static variables are declared.

#### Registers

These are small storage units located directly in the processor for quick access to intermediate values in function calls. It is known as L0 cache and it is located at the highest level in the [memory hierarchy](https://www.geeksforgeeks.org/memory-hierarchy-design-and-its-characteristics/).

There are six 32-bit general purpose registers in the x86 architecture [3]:

 * `eax` (extended accumulator register) - used for storing return values for functions and special register for certain calculations.

    * ```asm
      mov eax, 3  ; Set eax to 3
      ret			; Return
      ```

 * `ebx` (extended base register) - often set to commonly used values to speed up calculations.

 * `ecx` (extended counter register) - used as a function parameter or a loop counter. Generally used with *for loops* as the counter.

 * `edx` (extended data register) - also used as a function parameter register like `ecx` and storing **short-term variables** within a function.

 * `esi` (extended source index register) - register that points to the where the "source" is located in memory.

 * `edi` (extended data index register) - similar to `esi`, but it points to the destination. 

`ebp`, `esp`, and `eip` are all known as **reserved** registers.

#### Instructions

##### Format

There are essentially two schools of thought for instruction format: the **AT&T syntax** and the **Intel syntax**.

In short, the difference is that for the **AT&T syntax**, the source register is on the left side and the destination register is on the right side while it is the opposite for the **Intel syntax**.

Instructions typically follow 2 forms:

* `op arg` - there is an operation with only one argument specified.
* `op arg1, arg2` - there is an operation with two arguments specified, separated by a comma.

As an example with the `mov` instruction, it copies the value that is stored by the second argument into the first argument.

```asm
mov arg1, arg2
```

Although it is called `mov`, it actually **copies** instead, meaning that the value stored in `arg2` is actually still there. However, there are some caveats with this specific instruction in general discussed in the next section.

##### Dereferencing

The caveat comes when you are trying to get values from the stack.

â€‹	[insert figure]

When you are trying to get values from the stack, let's say moving a local variable at `ebp - 12 (0xC)` with a value of 42, you would expect that you would get the value that is stored at that location into `eax`. This means that `eax` should have the value of 42 right?

```asm
mov eax, ebp-0xC
```

**WRONG**

`ebp - 0xC` is an address that refers to where 42 is stored in memory. Simply calling `mov` will move that address into `eax`, but not 42. If you know C, you know that we would need to **dereference** a pointer to get the value at that location. In x86, a similar idea also exists where we can think of using the square bracket notation as a dereference operator.

So to get 42, we would run this:

```asm
mov eax, [ebp-0xC]
```



## Math
Of course, x86 supports the basic mathematical operators that you would need to perform more complex computations.

**Addition**
The `add` instruction is a binary operation that adds two given registers with the format `add arg1, arg2` which is the same as `arg1 = arg1 + arg2`. The first and second arguments are summed and stored in the first argument.

```asm
add eax, 0x5
```

The instruction above adds the value in `$eax` with 5 and stores it back in `$eax`.

**Subtraction**
This is a binary operation that subtracts the second argument from the first: `sub arg1, arg2` is the same as `arg1 = arg1 - arg2`.

```asm
sub esp, 0x4
```
The instruction above moves the stack pointer down 4 bytes.
This can also be done by adding a negative value with a lower overhead.

**Multiplication**
Multiplication is a bit more complex since it comes with several varying instructions.
Also, its destination register varies depending on the memory size of the value you are multiplying with.

1. Multiplying 2 bytes
2. Multiplying 2 half words (16 bits)
3. Multiplying 2 words (32 bits)


## Stack Based Operators

## Lea

## Compare

## Jump

## Call

## Ret



## References

1. [x86-64 Assembly Language Programming with Ubuntu](http://www.egr.unlv.edu/~ed/assembly64.pdf)

2. [2](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/)

3. [3](https://wiki.skullsecurity.org/index.php?title=Registers)

   
